'''
문제 설명

도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.
image.png
각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.
각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

제한사항
이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.
'''

def solution(money):
    N = len(money)

    # 첫번째 집부터 터는경우, 아닌경우
    def get_dp(start):
        dp = [0 for _ in range(N)]
        for i in range(start, N):
            dp[i] = max(dp[i - 1], dp[i - 2] + money[i])

        if start == 0:
            return dp[-2]
        return dp[-1]

    return max(get_dp(0), get_dp(1))


'''
정확성  테스트
테스트 1 〉	통과 (0.20ms, 10.2MB)
테스트 2 〉	통과 (0.59ms, 10.1MB)
테스트 3 〉	통과 (0.31ms, 10.1MB)
테스트 4 〉	통과 (0.04ms, 10.1MB)
테스트 5 〉	통과 (0.16ms, 10.2MB)
테스트 6 〉	통과 (0.34ms, 10.2MB)
테스트 7 〉	통과 (0.26ms, 10.3MB)
테스트 8 〉	통과 (0.18ms, 10.1MB)
테스트 9 〉	통과 (0.56ms, 10.2MB)
테스트 10 〉	통과 (0.12ms, 10.1MB)
효율성  테스트
테스트 1 〉	통과 (576.88ms, 68.8MB)
테스트 2 〉	통과 (543.79ms, 65.3MB)
테스트 3 〉	통과 (516.54ms, 67.5MB)
테스트 4 〉	통과 (571.29ms, 68.1MB)
테스트 5 〉	통과 (481.35ms, 56.9MB)
테스트 6 〉	통과 (505.49ms, 65.7MB)
테스트 7 〉	통과 (317.98ms, 42.2MB)
테스트 8 〉	통과 (328.82ms, 43.1MB)
테스트 9 〉	통과 (414.06ms, 48.6MB)
테스트 10 〉	통과 (508.01ms, 66.4MB)
'''